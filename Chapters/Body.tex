\chapter{Report Body}
%The central part of the report usually consists of three or four chapters detailing the technical work undertaken during the project. {\bf{\textcolor{red}{The structure of these chapters is highly project dependent}}}. They can reflect the chronological development of the project, e.g. design, implementation, experimentation, optimisation, evaluation, etc (although this is not always the best approach). However you choose to structure this part of the report, you should make it clear how you arrived at your chosen approach in preference to other alternatives. In terms of the software that you produce, you should describe and justify the design of your programs at some high level, e.g. using OMT, Z, VDL, etc., and you should document any interesting problems with, or features of, your implementation. Integration and testing are also important to discuss in some cases. You may include fragments of your source code in the main body of the report to illustrate points; the full source code is included in an appendix to your written report.

\section{Algorithms}

\subsection{Lindenmayer Systems}

Hungarian academic Aristid Lindenmayer devised a mathematical model for the reproduction of fungi in 1967.\cite{LINDENMAYER1968300} His model involved a string of symbols, each unique symbol denoting a specific action and/or branch. Essentially, running that initial string, called the \emph{axiom}, through a set of rules (called a \emph{grammar}) gives us an ever-expanding string that is then taken as instructions to draw something from. Lindenmayer Systems, or L-Systems, have since been used in several scenarios beyond its initial purpose of modelling fungi, from trees to fractals. In video games, they are frequently used to aid in the creation of foliage in several environments, as well as buildings and, here, level layouts.

\subsubsection{A Basic 0L-System}

The most basic form of L-System is a \emph{0L}-System, 0 in this case referring to the fact that the grammar is \emph{context-free}.

For this example\cite{lsyspaulbourke}, consider an alphabet $V$, which consists of the following symbols:

\newcommand{\F}{\mbox{F}}

$$ \F, +, - $$

where $\F$ means ``to go forward", and $+$ and $-$ denote turning right or left (respectively) a set number of degrees $\o$.

Take an axiom $\omega$, for example:

$$ \F+\F+\F+\F $$

And a set of rules $P$ which, in this case, is of size 1:

$$ \F \rightarrow \F+\F-\F-\F\F+\F+\F-\F $$

We can represent this \emph{parametric} L-system in the following form:\cite{enwiki:1124510226}

$$ G = (V, \omega, P) $$

To implement $G$ in Godot, we can take each rule and replace each string in accordance to our one rule, using the replace method, like so:

\begin{codeblock}{Simple String Replacement for an L-System with 1 rule}
string = string.replace(rule["from"], rule["to"]) #Here the rules were stored in dictionaries.
\end{codeblock}

The first 3 iterations of this operation are shown here:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{Images/initial-l-system-iteration-0.png}
	\caption{The axiom of the aforementioned simple L-System with just one rule. String size: 8.\\Source: Own work.}
	\label{fig:lsysiter0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{Images/initial-l-system-iteration-1.png}
	\caption{The first iteration of the aforementioned simple L-System with just one rule. String size: 59.\\Source: Own work.}
	\label{fig:lsysiter1}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{Images/initial-l-system-iteration-2.png}
	\caption{The second iteration of the aforementioned simple L-System with just one rule. String size: 475.\\Source: Own work.}
	\label{fig:lsysiter2}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{Images/initial-l-system-iteration-3.png}
	\caption{The third iteration of the aforementioned simple L-System with just one rule. String size: 3803. The string is too large to show in the window, as you can see here.\\Source: Own work.}
	\label{fig:lsysiter3}
\end{figure}

The resulting string can be used to draw a lattice.\cite{lsyspaulbourke} Examples of the above grammar in action are below.

\begin{figure}[H]
    \centering
    \includegraphics[height=0.25\textheight]{Images/lsys03.png}
    \caption{A lattice generated with the example grammar on a custom-written Classic Mac OS application specifically written for working with L-Systems.\cite{lsyspaulbourke}}
    \label{fig:lattice1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{Images/gd4lattice.png}
    \caption{A lattice generated with the example grammar on a Godot project for drawing from L-Systems. Source: Initial project written by YouTuber Codat\cite{codatGD3LSystemYT}\cite{codatGD3LSystemGH}, and converted to Godot 4 (with the addition of the lattice grammar) by me.\cite{codatGD4LSystemGH}}
    \label{fig:lattice2}
\end{figure}

\subsubsection{A More Complex D0L-System With More Than One Rule}

For handling more than one rule, we can instead use a new string buffer variable where, for each character in our string, we can attain a new string and append it to our string buffer. The resulting string is then returned and interpreted. This can be represented in Godot like so:

\begin{codeblock}{String replacement for an L-System with 2 rules}
func get_new_replacement(character: String) -> String:
	for rule in rules:
		if rule["from"] == character:
			return rule["to"]
	return ""

func replace_string(string: String) -> String:
	var new_string = ""
	for character in string:
		new_string += get_new_replacement(character)
	return new_string
\end{codeblock}

This can \textit{then} be used to handle more complex grammars that can handle more than one rule in which characters in strings are replaced by other strings of variable length, as before.

The grammar in the following example represents a D0L-System\cite{lsystemintro}, a \textbf{deterministic} L-System using a context-free grammar; the grammar in the first example was \textit{also} deterministic.

\newcommand{\A}{\mbox{a}}
\newcommand{\B}{\mbox{b}}

For this example, consider a new grammar $G$ with the alphabet $V$, where $\A$ and $\B$ are the only symbols. We start with the following axiom $\omega$, which is just $\A$. We now have a set of rules $P$ which is, this time, of size \textit{2}:

$$ \A \rightarrow \A\B $$
$$ \B \rightarrow \A $$

The first few steps of the resulting derivation can be modelled like so:

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{Images/derivationtree.png}
    \caption{The first few steps of a derivation of our example grammar.\cite{lsystemintro}}
    \label{fig:derivationtree}
\end{figure}

\subsection{Voronoi Cells}

Named after the Ukranian mathematician Georgy Voronoy, Voronoi cells work by taking a map of points, and randomly selecting a group of points. Within that selected group, cells are formed by calculating, in each point of the grid, the closest of the selected points to it. That is, each cell represents the group of points that are the closest to that random point (including that point in the group as well). The final arrangement of cells represents a Voronoi Diagram or Voronoi Tesselation.

Distances between points can be calculated with either the Euclidean distance:

$$ d_{E}(p, q) = \sqrt{(q_x - p_x)^2 + (q_y - p_y)^2} $$

or the Manhattan distance:

$$ d_{M}(p, q) = |q_x - p_x| + |q_y - p_y| $$

With the Euclidean distance producing a more ``triangulated" tesselation than the Manhattan distance, the geometry of which is more "blocky" and resembles taxicabs (hence its alternate name "Taxicab Geometry").

\subsection{Poisson Disk Sampling}

Poisson disk distributions are an easy way to randomly scatter objects across a field. It's commonly used for tree placement and placement of other random objects.

\subsection{Simplex Noise}

Kenneth Perlin designed a type of noise named after himself (Perlin Noise), in which each pixel of noise is affected by its surroundings. 

\section{Implementations}

Here I will describe, at surface level, the methods I went about implementing the above algorithms and what references I used.

\subsection{Lindenmayer System}

The implementation of an L-System was very simple. I took inspiration from a YouTube video on implementing an L-System for drawing line graphics in Godot by Codat.\cite{codatGD3LSystemYT} In the code from the Godot 3 project he made in that video\cite{codatGD3LSystemGH}\cite{codatGD3LSystemYT}, he created a custom ``Rule" class in GDScript, with which he defined new rules.

\subsection{Voronoi Cells}

\subsection{Poisson Disk Sampling}

\subsection{Simplex Noise}

The Simplex Noise implementation works with Godot's built-in Noise library. Within a Sprite2D node's Texture attribute, I set a new ``NoiseTexture2D" field inside of it. In its ``Noise" attribute I created a new ``FastNoiseLite" scene, which generates a noise texture for us to use. The seed can be set in the sprite's script file.

As with my other implementations, there are two separate arrays, one for trees and another for buildings. For each cell in the TileMap, I then took the noise pixel from the generated texture at that exact point (scaling with the cell size accordingly), and then, depending on the value retrieved, decided, firstly, whether or not to place a plant/tree tile there and, secondly, whether or not to place a building tile there. As a result, not every cell in the TileMap has tiles on it. On any one of those empty cells, the Player tile will then get placed.