\chapter{Conclusion and Future Work} \label{Conclusion}

% The project's conclusions should list the key things that have been learnt as a consequence of engaging in your project work. For example, ``The use of overloading in C++ provides a very elegant mechanism for transparent parallelisation of sequential programs'', or ``The overheads of linear-time n-body algorithms makes them computationally less efficient than $O(n \log n)$ algorithms for systems with less than 100000 particles''. Avoid tedious personal reflections like ``I learned a lot about C++ programming...'', or ``Simulating colliding galaxies can be real fun...''. It is common to finish the report by listing ways in which the project can be taken further. This might, for example, be a plan for turning a piece of software or hardware into a marketable product, or a set of ideas for possibly turning your project into an MPhil or PhD.

To conclude, the author of this report gained a wealth of knowledge about the way some of the most popular procedural content generation algorithms work, and how they are typically integrated into working games. He also learnt how he could leverage the features of the Godot game engine for some of them; for example, the ``FastNoiseLite" class allows a Godot game developer to generate noise textures in Value, Perlin and even Simplex noise and then modify them accordingly with additional frequency settings, fractal types and cellular distance functions. By implementing them in a self-designed 2D tiled RPG scenario, he was able to get 4 procedural generation algorithms well-integrated into working games, proving Godot's technical proficiency in making these kinds of games work, and proving his own abilities as a games programmer. He was also able to compare the implementations of his chosen algorithms in such a way that the differences, in terms of both performance times and the kinds of levels they produced, could very easily be discerned. The motives of this project can be pushed still further by measuring and comparing the performances of these algorithms in Big-O notation, including even more ontogenic algorithms such as Worley Noise, the Diamond-Square algorithm, Markov Chains and Cellular Automata, as well as telelogical algorithms such as the Rain Drop algorithm and Reaction-Diffusion systems, using a larger tile map on all of these algorithms and even using a different, more intensive scenario entirely, such as a 3D walking simulator/open-world game. With procedural generation for level design, the possibilites are practically endless.